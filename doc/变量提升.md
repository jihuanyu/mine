# 变量提升

1.  变量是如何被覆盖的

    -   一般情况下，JS 代码都是自上而下执行，对于同一个变量，修改方式如下

    ```
         var a = 1;
         a = 2;
         console.log(a) // 2
         a = function(){};
         console.log(a) // function(){};
    ```

2.  变量提升

    -   覆盖其实很好理解

    ```
        console.log(a);
        var a = 1;
        console.log(b);
        function b(){};
    ```

        这个时候 console.log()都会输出 undefined 而不会报错，这是为什么呢？这里就是变量提升起到的作用。我们在用 var 或者函数声明的方式定义一个变量时，这个变量的定义会提升到方法体的最顶端，即如下所示：

    ```
        var a = undefined;
        var b = undefined;
        console.log(a)
        console.log(b)
    ```

        函数声明和变量声明总是会被解释器悄悄地被"提升"到方法体的最顶部。

3.  更近一步——变量提升的优先级

    -   直接剖出问题：

    ```
        var a = 1;
        function a(){
        console.log(a)
        }
        console.log(a)
    ```

        此时的代码会打印：1，因为在变量提升中，函数的提升优先级会高于变量的提升优先级。而浏览器底层的实现过程是这样的：当JS解析器在遇到函数声明时，会优先将其提升到顶部，其次再是var声明的变量，这就导致了函数声明的变量a被var声明的变量a给覆盖的情况，所以最终打印出来是：1。

4.  函数参数作用域与作用域链

    -   作用域就是变量和函数可以访问的范围，作用域的第一个对象始终是当前执行代码所在的环境变量。然后会一层一层的向外查找，直到找到第一个指定的变量为止。

    ```
        var a = {name: 'xuexi'};
        function b(a){
            a.age = 12;
            a = {num: 1};
            return a
        }
        var a1 = b(a);
        console.log(a, a1)

    ```

    ```
    这是一道面试题！！！

    （1）我们根据之前介绍的作用域和作用域链的概念可以知道，在函数体内，变量会就近查找，而函数参数会存在于函数体内部作用域中，所以当我们把全局变量a当作入参传递给函数时，又由于全局a是引用类型，此时只是引用了它的地址，那么我们通过a.age设置属性时，全局a也会改变。

    （2）第二步是将a赋予了一个新的值，此时的a根据就近查找其实是参数a，本质上是将参数a赋予了一个新的对象，这个时候和全局变量的a没有任何关系了，此时函数最后会返回一个新的对象。
    综上两步分析，我们就会明白为什么打印a时输出的是{name: 'xuexi', age: 12},打印a1会输出{num: 1}了。
    ```

# 总结

    函数声明提升，变量作用域以及作用域链这块一直是学习javascript的基础也是重点，所以希望这篇文章可以让大家更好的掌握它

文章摘自：掘金

链接：https://juejin.im/post/5dbc49db6fb9a020512b3f8f
